# ------------------------------------------------------ #
#
# abaqus python code 
# generate 3D Voronoi model using point/line/face infos of .tess file generated by Neper
# Created: 12/27/2019
# Modified: 12/28/2019
# Author: Yan Chen, P.hd, Xi'an Jiatong University
# Email: chenyanc@stu.xjtu.edu.cn
# 
# ------------------------------------------------------ #

from abaqus import *
from abaqusConstants import *
import os
import math
import numpy as np
from caeModules import *
from driverUtils import executeOnCaeStartup
executeOnCaeStartup()


def ReadTess(file_header):
	# Open the .tess file, and read all the lines. Store only the contents of the sections named
	# **vertex **edge  and **face for further parsing of the system.
	
	# Open the file
	with open(file_header + '.tess') as file:
		content = file.read().splitlines()
	
	# Initialize data saving arrays
	vertex=[]
	edge=[]
	face=[]
	vertex_flag = 0
	edge_flag = 0
	face_flag = 0
	
	# Strip only the CELL and COORD sections
	for line in range (0, len(content)):
		content_line = content[line].lstrip()
		if content_line == '**vertex':
			vertex_flag = 1
		if content_line == '**edge':
			vertex_flag = 0
			edge_flag = 1
		if content_line == '**face':
			edge_flag = 0
			face_flag = 1
		if content_line == '**polyhedron':
			face_flag = 0
			
		# Strip only the vertex, edge, and face sections	
		if vertex_flag == 1:
			vertex.append(content_line)
		if edge_flag == 1:
			edge.append(content_line)
		if face_flag == 1:
			face.append(content_line)		
	# Return the information	
	return (vertex, edge, face)

#def Line_inverse(line):

file_name = 'gene_morp4_3-lognormal0.12'
vertex, edge, face=ReadTess(file_name)

Num_vertex = int(vertex[1])
Num_edge = int(edge[1])
Num_face = int(face[1])
del vertex[0:2]
del edge[0:2]
del face[0:2]

#for item in vertex: print(item)

p = mdb.models['Model-1'].Part(name='Part-1',dimensionality=THREE_D, type=DEFORMABLE_BODY)
p = mdb.models['Model-1'].parts['Part-1']

lenX = 2000
lenY = 2000
lenZ = 2000

# ------------------------------------------------------ #
# plot all edges
# note that, mid-points for all edges should be saved
# edges can be conviently indexed by: p.edges.findAt((X, Y, Z))
# ------------------------------------------------------ #

# for item in p.edges:print(item)
Mid_point_edge=np.zeros((Num_edge,3))
for eLine in edge:
	id_line = int(eLine.split()[0]) -1
	n_v1 = int(eLine.split()[1]) # index for 1st vertex
	n_v2 = int(eLine.split()[2]) # index for 2nd vertex
	vertex1 = vertex[n_v1-1].split()[1:4]
	vertex2 = vertex[n_v2-1].split()[1:4]
	point1_x = lenX*float(vertex1[0])
	point1_y = lenY*float(vertex1[1])
	point1_z = lenZ*float(vertex1[2])
	point2_x = lenX*float(vertex2[0])
	point2_y = lenY*float(vertex2[1])
	point2_z = lenZ*float(vertex2[2])
	Mid_point_edge[id_line][0] = (point1_x+point2_x)/2
	Mid_point_edge[id_line][1] = (point1_y+point2_y)/2
	Mid_point_edge[id_line][2] = (point1_z+point2_z)/2
	#Mid_point_edge = Mid_point_edge.append([mid_point_x,mid_point_y,mid_point_z])	
	p.WirePolyLine(points=(((point1_x,point1_y,point1_z),(point2_x,point2_y,point2_z)),), mergeWire=OFF,meshable=ON)

for i in range(Num_face):
	vertex_info = face[4*i]     # vertex of face i
	edge_info = face[4*i+1]   # edges of face i
	edge_list = edge_info.split()  # edgeList for constructing face via CoverEdges
	edge_n = int(edge_list[0])
	CoverEdges_edgeList=[]
	for nLine in edge_list[1:]:
		id_edge = abs(int(nLine))-1  # negative of edge id represents the negative direction
		e_i = p.edges.findAt((Mid_point_edge[id_edge][0], Mid_point_edge[id_edge][1], Mid_point_edge[id_edge][2]))
		CoverEdges_edgeList.append(e_i)
	p.CoverEdges(CoverEdges_edgeList, tryAnalytical=True)

	
	
#mid=[]
#for nLine in edge_list[1:]:
#	id_edge = int(nLine)-1
#	mid=mid.append(((Mid_point_edge[id_edge][0], Mid_point_edge[id_edge][1], Mid_point_edge[id_edge][2]),))
#eList = p.edges.findAt(mid)
#p.CoverEdges(eList, tryAnalytical=True)
	
	
	
	
	
	
	
	
	
	
